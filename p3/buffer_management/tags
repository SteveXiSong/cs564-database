!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ASSERT	buf.cpp	11;"	d	file:
ASSERT	error.h	70;"	d
ATTRNOTFOUND	error.h	/^       BADCATPARM, RELNOTFOUND, ATTRNOTFOUND,$/;"	e	enum:Status
ATTRTOOLONG	error.h	/^       INDEXEXISTS, ATTRTOOLONG,$/;"	e	enum:Status
ATTRTYPEMISMATCH	error.h	/^       ATTRTYPEMISMATCH, TMP_RES_EXISTS,$/;"	e	enum:Status
BADBUFFER	error.h	/^       BADBUFFER, PAGEPINNED,$/;"	e	enum:Status
BADCATPARM	error.h	/^       BADCATPARM, RELNOTFOUND, ATTRNOTFOUND,$/;"	e	enum:Status
BADFILE	error.h	/^       BADFILEPTR, BADFILE, FILETABFULL, FILEOPEN, FILENOTOPEN,$/;"	e	enum:Status
BADFILEPTR	error.h	/^       BADFILEPTR, BADFILE, FILETABFULL, FILEOPEN, FILENOTOPEN,$/;"	e	enum:Status
BADINDEXPARM	error.h	/^       BADINDEXPARM, RECNOTFOUND, BUCKETFULL, DIROVERFLOW, $/;"	e	enum:Status
BADPAGENO	error.h	/^       UNIXERR, BADPAGEPTR, BADPAGENO, FILEEXISTS,$/;"	e	enum:Status
BADPAGEPTR	error.h	/^       UNIXERR, BADPAGEPTR, BADPAGENO, FILEEXISTS,$/;"	e	enum:Status
BADRECPTR	error.h	/^       BADRID, BADRECPTR, BADSCANPARM, BADSCANID, SCANTABFULL, FILEEOF, FILEHDRFULL,$/;"	e	enum:Status
BADRID	error.h	/^       BADRID, BADRECPTR, BADSCANPARM, BADSCANID, SCANTABFULL, FILEEOF, FILEHDRFULL,$/;"	e	enum:Status
BADSCANID	error.h	/^       BADRID, BADRECPTR, BADSCANPARM, BADSCANID, SCANTABFULL, FILEEOF, FILEHDRFULL,$/;"	e	enum:Status
BADSCANPARM	error.h	/^       BADRID, BADRECPTR, BADSCANPARM, BADSCANID, SCANTABFULL, FILEEOF, FILEHDRFULL,$/;"	e	enum:Status
BADSORTPARM	error.h	/^       BADSORTPARM, INSUFMEM, $/;"	e	enum:Status
BUCKETFULL	error.h	/^       BADINDEXPARM, RECNOTFOUND, BUCKETFULL, DIROVERFLOW, $/;"	e	enum:Status
BUFFEREXCEEDED	error.h	/^       HASHTBLERROR, HASHNOTFOUND, BUFFEREXCEEDED, PAGENOTPINNED,$/;"	e	enum:Status
BUF_H	buf.h	2;"	d
BufDesc	buf.h	/^  BufDesc() {$/;"	f	class:BufDesc
BufDesc	buf.h	/^class BufDesc {$/;"	c
BufHashTbl	buf.h	/^class BufHashTbl$/;"	c
BufHashTbl	bufHash.cpp	/^BufHashTbl::BufHashTbl(int htSize)$/;"	f	class:BufHashTbl
BufMgr	buf.cpp	/^BufMgr::BufMgr(const int bufs)$/;"	f	class:BufMgr
BufMgr	buf.h	/^class BufMgr $/;"	c
BufStats	buf.h	/^  BufStats()$/;"	f	struct:BufStats
BufStats	buf.h	/^struct BufStats$/;"	s
CALL	testbuf.cpp	11;"	d	file:
CXX	Makefile	/^CXX = g++$/;"	m
CXXFLAGS	Makefile	/^CXXFLAGS = -g -Wall$/;"	m
Clear	buf.h	/^  void Clear() {  \/\/ initialize buffer frame for a new user$/;"	f	class:BufDesc
DB	db.cpp	/^DB::DB()$/;"	f	class:DB
DB	db.h	/^class DB {$/;"	c
DBP	db.cpp	14;"	d	file:
DBPage	db.h	/^} DBPage;$/;"	t	typeref:struct:__anon1
DB_H	db.h	2;"	d
DIROVERFLOW	error.h	/^       BADINDEXPARM, RECNOTFOUND, BUCKETFULL, DIROVERFLOW, $/;"	e	enum:Status
DPFIXED	page.h	/^const unsigned DPFIXED= sizeof(slot_t)+4*sizeof(short)+2*sizeof(int);$/;"	v
DUPLATTR	error.h	/^       NAMETOOLONG, DUPLATTR, RELEXISTS, NOINDEX,$/;"	e	enum:Status
ENDOFPAGE	error.h	/^       NOSPACE,  NORECORDS,  ENDOFPAGE, INVALIDSLOTNO, INVALIDRECLEN,$/;"	e	enum:Status
ERROR_H	error.h	3;"	d
Error	error.h	/^class Error {$/;"	c
FAIL	testbuf.cpp	20;"	d	file:
FILEEOF	error.h	/^       BADRID, BADRECPTR, BADSCANPARM, BADSCANID, SCANTABFULL, FILEEOF, FILEHDRFULL,$/;"	e	enum:Status
FILEEXISTS	error.h	/^       UNIXERR, BADPAGEPTR, BADPAGENO, FILEEXISTS,$/;"	e	enum:Status
FILEHDRFULL	error.h	/^       BADRID, BADRECPTR, BADSCANPARM, BADSCANID, SCANTABFULL, FILEEOF, FILEHDRFULL,$/;"	e	enum:Status
FILENOTOPEN	error.h	/^       BADFILEPTR, BADFILE, FILETABFULL, FILEOPEN, FILENOTOPEN,$/;"	e	enum:Status
FILEOPEN	error.h	/^       BADFILEPTR, BADFILE, FILETABFULL, FILEOPEN, FILENOTOPEN,$/;"	e	enum:Status
FILETABFULL	error.h	/^       BADFILEPTR, BADFILE, FILETABFULL, FILEOPEN, FILENOTOPEN,$/;"	e	enum:Status
File	db.cpp	/^File::File(const string & fname)$/;"	f	class:File
File	db.h	/^class File {$/;"	c
HASHNOTFOUND	error.h	/^       HASHTBLERROR, HASHNOTFOUND, BUFFEREXCEEDED, PAGENOTPINNED,$/;"	e	enum:Status
HASHTBLERROR	error.h	/^       HASHTBLERROR, HASHNOTFOUND, BUFFEREXCEEDED, PAGENOTPINNED,$/;"	e	enum:Status
HTSIZE	buf.h	/^    int HTSIZE;$/;"	m	class:BufHashTbl
HTSIZE	db.h	/^    int HTSIZE;$/;"	m	class:OpenFileHashTbl
INDEXEXISTS	error.h	/^       INDEXEXISTS, ATTRTOOLONG,$/;"	e	enum:Status
INSUFMEM	error.h	/^       BADSORTPARM, INSUFMEM, $/;"	e	enum:Status
INVALIDRECLEN	error.h	/^       NOSPACE,  NORECORDS,  ENDOFPAGE, INVALIDSLOTNO, INVALIDRECLEN,$/;"	e	enum:Status
INVALIDSLOTNO	error.h	/^       NOSPACE,  NORECORDS,  ENDOFPAGE, INVALIDSLOTNO, INVALIDRECLEN,$/;"	e	enum:Status
LD	Makefile	/^LD = ld$/;"	m
LDFLAGS	Makefile	/^LDFLAGS =$/;"	m
MAKEFILE	Makefile	/^MAKEFILE = Makefile$/;"	m
NAMETOOLONG	error.h	/^       NAMETOOLONG, DUPLATTR, RELEXISTS, NOINDEX,$/;"	e	enum:Status
NOINDEX	error.h	/^       NAMETOOLONG, DUPLATTR, RELEXISTS, NOINDEX,$/;"	e	enum:Status
NOMORERECS	error.h	/^       NONUNIQUEENTRY, NOMORERECS,$/;"	e	enum:Status
NONUNIQUEENTRY	error.h	/^       NONUNIQUEENTRY, NOMORERECS,$/;"	e	enum:Status
NORECORDS	error.h	/^       NOSPACE,  NORECORDS,  ENDOFPAGE, INVALIDSLOTNO, INVALIDRECLEN,$/;"	e	enum:Status
NOSPACE	error.h	/^       NOSPACE,  NORECORDS,  ENDOFPAGE, INVALIDSLOTNO, INVALIDRECLEN,$/;"	e	enum:Status
NOTUSED1	error.h	/^       OK = 0, NOTUSED1 = -999,$/;"	e	enum:Status
NOTUSED2	error.h	/^       NOTUSED2$/;"	e	enum:Status
NULLRID	page.h	/^const RID NULLRID = {-1,-1};$/;"	v
OBJS	Makefile	/^OBJS =  db.o buf.o bufHash.o error.o page.o testbuf.o $/;"	m
OBJS2	Makefile	/^OBJS2 =  db.o buf.o bufHash.o error.o$/;"	m
OK	error.h	/^       OK = 0, NOTUSED1 = -999,$/;"	e	enum:Status
OpenFileHashTbl	db.cpp	/^OpenFileHashTbl::OpenFileHashTbl()$/;"	f	class:OpenFileHashTbl
OpenFileHashTbl	db.h	/^class OpenFileHashTbl$/;"	c
PAGEDATASIZE	page.h	/^const unsigned PAGEDATASIZE = PAGESIZE-DPFIXED+sizeof(slot_t);$/;"	v
PAGENOTPINNED	error.h	/^       HASHTBLERROR, HASHNOTFOUND, BUFFEREXCEEDED, PAGENOTPINNED,$/;"	e	enum:Status
PAGEPINNED	error.h	/^       BADBUFFER, PAGEPINNED,$/;"	e	enum:Status
PAGESIZE	page.h	/^const unsigned PAGESIZE = 1024;$/;"	v
PAGE_H	page.h	2;"	d
PURIFY	Makefile	/^PURIFY = purify -collector=\/usr\/ccs\/bin\/ld -g++$/;"	m
Page	page.h	/^class Page {$/;"	c
RECNOTFOUND	error.h	/^       BADINDEXPARM, RECNOTFOUND, BUCKETFULL, DIROVERFLOW, $/;"	e	enum:Status
RELEXISTS	error.h	/^       NAMETOOLONG, DUPLATTR, RELEXISTS, NOINDEX,$/;"	e	enum:Status
RELNOTFOUND	error.h	/^       BADCATPARM, RELNOTFOUND, ATTRNOTFOUND,$/;"	e	enum:Status
RID	page.h	/^struct RID{$/;"	s
Record	page.h	/^struct Record$/;"	s
SCANTABFULL	error.h	/^       BADRID, BADRECPTR, BADSCANPARM, BADSCANID, SCANTABFULL, FILEEOF, FILEHDRFULL,$/;"	e	enum:Status
SRCS	Makefile	/^SRCS =	db.cpp buf.cpp bufHash.cpp error.cpp page.cpp testbuf.cpp $/;"	m
Set	buf.h	/^  void Set(File* filePtr, int pageNum) { $/;"	f	class:BufDesc
Status	error.h	/^enum Status {$/;"	g
TMP_RES_EXISTS	error.h	/^       ATTRTYPEMISMATCH, TMP_RES_EXISTS,$/;"	e	enum:Status
UNIXERR	error.h	/^       UNIXERR, BADPAGEPTR, BADPAGENO, FILEEXISTS,$/;"	e	enum:Status
accesses	buf.h	/^  int accesses;    \/\/ Total number of accesses to buffer pool$/;"	m	struct:BufStats
advanceClock	buf.h	/^  void advanceClock()$/;"	f	class:BufMgr
allocBuf	buf.cpp	/^const Status BufMgr::allocBuf(int & frame) {$/;"	f	class:BufMgr
allocPage	buf.cpp	/^const Status BufMgr::allocPage(File* file, int& pageNo, Page*& page)  {$/;"	f	class:BufMgr
allocatePage	db.cpp	/^Status File::allocatePage(int& pageNo)$/;"	f	class:File
bufMgr	testbuf.cpp	/^BufMgr*     bufMgr;$/;"	v
bufPool	buf.h	/^  Page*	         bufPool;   \/\/ actual buffer pool$/;"	m	class:BufMgr
bufStats	buf.h	/^  BufStats	 bufStats;	\/\/ buffer pool statistics$/;"	m	class:BufMgr
bufTable	buf.h	/^  BufDesc*	 bufTable;  	\/\/ vector of status info, 1 per page$/;"	m	class:BufMgr
clear	buf.h	/^  void clear()$/;"	f	struct:BufStats
clearBufStats	buf.h	/^  const void clearBufStats() $/;"	f	class:BufMgr
clockHand	buf.h	/^  unsigned int 	 clockHand;$/;"	m	class:BufMgr
close	db.cpp	/^const Status File::close()$/;"	f	class:File
closeFile	db.cpp	/^const Status DB::closeFile(File* file)$/;"	f	class:DB
create	db.cpp	/^Status const File::create(const string & fileName)$/;"	f	class:File
createFile	db.cpp	/^const Status DB::createFile(const string &fileName) $/;"	f	class:DB
curPage	page.h	/^    int		curPage;  \/\/ page number of current pointer$/;"	m	class:Page
data	page.h	/^    char 	data[PAGESIZE - DPFIXED]; $/;"	m	class:Page
data	page.h	/^  void* data;$/;"	m	struct:Record
deleteRecord	page.cpp	/^const Status Page::deleteRecord(const RID & rid)$/;"	f	class:Page
destroy	db.cpp	/^const Status File::destroy(const string & fileName)$/;"	f	class:File
destroyFile	db.cpp	/^const Status DB::destroyFile(const string & fileName) $/;"	f	class:DB
dirty	buf.h	/^  bool 	dirty;	  \/\/ true if dirty;  false otherwise$/;"	m	class:BufDesc
diskreads	buf.h	/^  int diskreads;   \/\/ Number of pages read from disk (including allocs)$/;"	m	struct:BufStats
diskwrites	buf.h	/^  int diskwrites;  \/\/ Number of pages written back to disk$/;"	m	struct:BufStats
disposePage	buf.cpp	/^const Status BufMgr::disposePage(File* file, const int pageNo) {$/;"	f	class:BufMgr
disposePage	db.cpp	/^const Status File::disposePage(const int pageNo)$/;"	f	class:File
dummy	page.h	/^    short	dummy;	\/\/ for alignment purposes$/;"	m	class:Page
dumpPage	page.cpp	/^void Page::dumpPage() const$/;"	f	class:Page
erase	db.cpp	/^Status OpenFileHashTbl::erase(const string fileName)$/;"	f	class:OpenFileHashTbl
file	buf.h	/^	File*	file;    \/\/ pointer a file object (more on this below)$/;"	m	struct:hashBucket
file	buf.h	/^  File* file;   \/\/ pointer to file object$/;"	m	class:BufDesc
file	db.h	/^        File*   file;    \/\/ pointer to file object$/;"	m	struct:fileHashBucket
fileHashBucket	db.h	/^struct fileHashBucket$/;"	s
fileName	db.h	/^  string fileName;                    \/\/ The name of the file$/;"	m	class:File
find	db.cpp	/^Status OpenFileHashTbl::find(const string fileName, File*& file)$/;"	f	class:OpenFileHashTbl
firstPage	db.h	/^  int firstPage;                        \/\/ page # of first page in file$/;"	m	struct:__anon1
firstRecord	page.cpp	/^const Status Page::firstRecord(RID& firstRid) const$/;"	f	class:Page
flushFile	buf.cpp	/^const Status BufMgr::flushFile(const File* file) {$/;"	f	class:BufMgr
fname	db.h	/^	string	fname;    \/\/ name of the file$/;"	m	struct:fileHashBucket
frameNo	buf.h	/^	int	frameNo; \/\/ frame number of page in the buffer pool$/;"	m	struct:hashBucket
frameNo	buf.h	/^  int	frameNo;  \/\/ frame # of frame$/;"	m	class:BufDesc
freePtr	page.h	/^    short	freePtr; \/\/ offset of first free byte in data[]$/;"	m	class:Page
freeSpace	page.h	/^    short	freeSpace; \/\/ number of bytes free in data[]$/;"	m	class:Page
getBufStats	buf.h	/^  const BufStats & getBufStats() const \/\/ get buffer pool usage$/;"	f	class:BufMgr
getFirstPage	db.cpp	/^const Status File::getFirstPage(int& pageNo) const$/;"	f	class:File
getFreeSpace	page.cpp	/^const short Page::getFreeSpace() const$/;"	f	class:Page
getNextPage	page.cpp	/^const Status Page::getNextPage(int& pageNo) const$/;"	f	class:Page
getRecord	page.cpp	/^const Status Page::getRecord(const RID & rid, Record & rec)$/;"	f	class:Page
hash	bufHash.cpp	/^int BufHashTbl::hash(const File* file, const int pageNo)$/;"	f	class:BufHashTbl
hash	db.cpp	/^int OpenFileHashTbl::hash(const string fileName)$/;"	f	class:OpenFileHashTbl
hashBucket	buf.h	/^struct hashBucket$/;"	s
hashTable	buf.h	/^  BufHashTbl*    hashTable;  	\/\/ hash table mapping (File, page) to frame$/;"	m	class:BufMgr
ht	buf.h	/^    hashBucket**  ht; \/\/ actual hash table$/;"	m	class:BufHashTbl
ht	db.h	/^    fileHashBucket**  ht; \/\/ actual hash table$/;"	m	class:OpenFileHashTbl
init	page.cpp	/^void Page::init(int pageNo)$/;"	f	class:Page
insert	bufHash.cpp	/^Status BufHashTbl::insert(const File* file, const int pageNo, const int frameNo) {$/;"	f	class:BufHashTbl
insert	db.cpp	/^Status OpenFileHashTbl::insert(const string fileName, File* file ) $/;"	f	class:OpenFileHashTbl
insertRecord	page.cpp	/^const Status Page::insertRecord(const Record & rec, RID& rid)$/;"	f	class:Page
intread	db.cpp	/^const Status File::intread(int pageNo, Page* pagePtr) const$/;"	f	class:File
intwrite	db.cpp	/^const Status File::intwrite(const int pageNo, const Page* pagePtr)$/;"	f	class:File
length	page.h	/^        short	length;  \/\/ equals -1 if slot is not in use$/;"	m	struct:slot_t
length	page.h	/^  int length;$/;"	m	struct:Record
listFree	db.cpp	/^void File::listFree()$/;"	f	class:File
lookup	bufHash.cpp	/^Status BufHashTbl::lookup(const File* file, const int pageNo, int& frameNo) $/;"	f	class:BufHashTbl
main	testbuf.cpp	/^int main()$/;"	f
next	buf.h	/^	hashBucket* 	next;	 \/\/ next node in the hash table$/;"	m	struct:hashBucket
next	db.h	/^	fileHashBucket* next;	 \/\/ next node in the hash table$/;"	m	struct:fileHashBucket
nextFree	db.h	/^  int nextFree;                         \/\/ page # of next page on free list$/;"	m	struct:__anon1
nextPage	page.h	/^    int		nextPage; \/\/ forwards pointer$/;"	m	class:Page
nextRecord	page.cpp	/^const Status Page::nextRecord (const RID &curRid, RID& nextRid) const$/;"	f	class:Page
numBufs	buf.h	/^  int   	 numBufs;    	\/\/ Number of pages in buffer pool$/;"	m	class:BufMgr
numPages	db.h	/^  int numPages;                         \/\/ total # of pages in file$/;"	m	struct:__anon1
offset	page.h	/^        short	offset;  $/;"	m	struct:slot_t
open	db.cpp	/^const Status File::open()$/;"	f	class:File
openCnt	db.h	/^  int openCnt;                        \/\/ # times file has been opened$/;"	m	class:File
openFile	db.cpp	/^const Status DB::openFile(const string & fileName, File*& filePtr)$/;"	f	class:DB
openFiles	db.h	/^  OpenFileHashTbl   openFiles;    \/\/ list of open files$/;"	m	class:DB
operator ==	db.h	/^  bool operator == (const File & other) const$/;"	f	class:File
pageNo	buf.h	/^	int	pageNo;  \/\/ page number within a file$/;"	m	struct:hashBucket
pageNo	buf.h	/^  int   pageNo; \/\/ page within file$/;"	m	class:BufDesc
pageNo	page.h	/^    int  pageNo;$/;"	m	struct:RID
pinCnt	buf.h	/^  int   pinCnt; \/\/ number of times this page has been pinned$/;"	m	class:BufDesc
print	error.cpp	/^void Error::print(Status status)$/;"	f	class:Error
printSelf	buf.cpp	/^void BufMgr::printSelf(void) $/;"	f	class:BufMgr
readPage	buf.cpp	/^const Status BufMgr::readPage(File* file, const int PageNo, Page*& page) {$/;"	f	class:BufMgr
readPage	db.cpp	/^const Status File::readPage(const int pageNo, Page* pagePtr) const$/;"	f	class:File
refbit	buf.h	/^  bool  refbit;	 \/\/ has this buffer frame been reference recently$/;"	m	class:BufDesc
remove	bufHash.cpp	/^Status BufHashTbl::remove(const File* file, const int pageNo) {$/;"	f	class:BufHashTbl
setNextPage	page.cpp	/^const Status Page::setNextPage(int pageNo)$/;"	f	class:Page
slot	page.h	/^    slot_t 	slot[1]; \/\/ first element of slot array - grows backwards!$/;"	m	class:Page
slotCnt	page.h	/^    short	slotCnt; \/\/ number of slots in use;$/;"	m	class:Page
slotNo	page.h	/^    int	 slotNo;$/;"	m	struct:RID
slot_t	page.h	/^struct slot_t {$/;"	s
unPinPage	buf.cpp	/^const Status BufMgr::unPinPage(File* file, const int PageNo, $/;"	f	class:BufMgr
unixFile	db.h	/^  int unixFile;                       \/\/ unix file stream for file$/;"	m	class:File
valid	buf.h	/^  bool 	valid;   \/\/ true if page is valid$/;"	m	class:BufDesc
writePage	db.cpp	/^const Status File::writePage(const int pageNo, const Page *pagePtr)$/;"	f	class:File
~BufHashTbl	bufHash.cpp	/^BufHashTbl::~BufHashTbl()$/;"	f	class:BufHashTbl
~BufMgr	buf.cpp	/^BufMgr::~BufMgr() {$/;"	f	class:BufMgr
~DB	db.cpp	/^DB::~DB()$/;"	f	class:DB
~File	db.cpp	/^File::~File()$/;"	f	class:File
~OpenFileHashTbl	db.cpp	/^OpenFileHashTbl::~OpenFileHashTbl()$/;"	f	class:OpenFileHashTbl
